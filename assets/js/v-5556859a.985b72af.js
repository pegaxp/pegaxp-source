"use strict";(self.webpackChunkpegaxp=self.webpackChunkpegaxp||[]).push([[952],{5737:(a,e,s)=>{s.r(e),s.d(e,{data:()=>o});const o={key:"v-5556859a",path:"/guide/foundation.html",title:"Fundação",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Database",slug:"database",children:[]},{level:2,title:"Ruleset",slug:"ruleset",children:[{level:3,title:"Ruleset version",slug:"ruleset-version",children:[]}]},{level:2,title:"Class",slug:"class",children:[]}],filePathRelative:"guide/foundation.md",git:{updatedTime:1636921434e3,contributors:[{name:"Ian Lucas",email:"ianlucas_ferreira@hotmail.com",commits:1}]}}},1667:(a,e,s)=>{s.r(e),s.d(e,{default:()=>t});const o=(0,s(6252).uE)('<h1 id="fundacao" tabindex="-1"><a class="header-anchor" href="#fundacao" aria-hidden="true">#</a> Fundação</h1><p>De um ponto de vista técnico, toda aplicação Pega é uma aplicação de banco de dados, isto é, todos objetos da aplicação são persistidos em banco, inclusive assets como arquivos de estilo e JavaScript. Essa noção inicial é importante para sabermos medir performance de uma aplicação Pega.</p><p>A plataforma trata seus objetos como &quot;regras&quot;, esses objetos são persistidos em tabelas do banco de dados (esquemas PegaRULES ou PegaDATA) e normalmente se traduzem em código Java em tempo de execução. O back-end do Pega é Java, todas as regras low-code são traduzidas em Java.</p><h2 id="database" tabindex="-1"><a class="header-anchor" href="#database" aria-hidden="true">#</a> Database</h2><p>Para a instalação da plataforma, precisamos de um banco de dados relacional. A plataforma possui esquemas padrões para guardar seus objetos, em particular:</p><ul><li><strong>PegaRULES</strong>, onde as regras são persitidas, de todas aplicações Pega, incluindo a própria aplicação de desenvolvimento;</li><li><strong>PegaDATA</strong>, onde se persiste instâncias de dados utilizados na aplicação.</li></ul><h2 id="ruleset" tabindex="-1"><a class="header-anchor" href="#ruleset" aria-hidden="true">#</a> Ruleset</h2><p>Para comportar as regras de uma aplicação, precisamos de uma Ruleset para associar e juntar as regras, assim, uma Ruleset é um conjunto de regras que podem, ou não ser <em>versionadas</em>.</p><p>Por exemplo, imagine que você tenha uma tabela do banco mapeada na aplicação, a configuração desta tabela na aplicação está atrelada a uma Ruleset e não necessita de um versionamento. Normalmente, regras de configuração não são versionadas.</p><h3 id="ruleset-version" tabindex="-1"><a class="header-anchor" href="#ruleset-version" aria-hidden="true">#</a> Ruleset version</h3><p>Uma Ruleset version é uma versão de uma ruleset. Por exemplo, podemos ter uma Ruleset <code>Vacinacao:01-01-01</code>, que possui regras específicas para essa versão, <code>01-01-01</code>, para uma aplicação de campanha de vacinação.</p><h2 id="class" tabindex="-1"><a class="header-anchor" href="#class" aria-hidden="true">#</a> Class</h2><p>Uma Class define o contexto de uma regra, esse contexto ajuda a definir a estrutura de dados que será seguida.</p>',13),r={},t=(0,s(3744).Z)(r,[["render",function(a,e){return o}]])},3744:(a,e)=>{e.Z=(a,e)=>{for(const[s,o]of e)a[s]=o;return a}}}]);